## HttpSession의 getAttribute가 사용자마다 어떻게 구분되는지
* 사용자마다 HttpSession을 할당받고 해당되는 고유한 ID를 서버 메모리에 저장
* Cookie에 저장되는 JSESSIONID를 통해 요청마다 해당되는 HttpSession 값을 가져와서 처리함

## 쉘 스크립트의 return문
* 값을 반환하는 기능이 없음
* 마지막 줄에 echo로 리턴할 값 출력
* 클라이언트에서 그 값을 잡아서 사용
  * $(함수명)

## JPA에서 1:N 관계의 테이블을 실제로 Join 쿼리를 이용하면 어떻게 되는지
* fetch join
  * inner join
* 자식 엔티티 수만큼 부모 엔티티 중복
* LinkedHashSet
* selectDistinct

## equals()와 hashCode()
* equals() 재정의하면 hashCode()도 같이 재정의
* HashMap이나 HashSet을 쓸때 문제 발생함

## RDBMS 인덱스
* 일종의 목차를 생성
* B-Tree 인덱스 구조
* Root->Branch->Leaf->디스크 저장소
* 뒤의 컬럼은 앞의 컬럼에 의존
* 인덱스 수는 3~4개가 적당

### 인덱스 키 값의 크기
* 페이지 단위로 관리
* 인덱스 키가 커지면 성능 저하 발생

### 인덱스 컬럼 기준
* 카디널리티가 가장 높은 것
  * 중복된 수치
  * 성별과 주민등록번호 예시

### 여러 컬럼 인덱스 구성시 기준
* 가디널리티가 높은 순에서 낮은 순

### 여러 컬럼 인덱스 누락 조건
* 첫번째 인덱스 컬럼이 조회 쿼리에 없으면 인덱스 타지 않음

### 인덱스 조회 시 주의 사항
* 범위 조건은 해당 컬럼만 인덱스 탐
  * between, like, <, >
* =, in은 다음 컬럼도 인덱스 탐
  * 서브쿼리 제외
* or 연산자는 풀 테이블 스캔 발생 확률 높음
* 컬럼값 형태 그대로 사용

### 인덱스 컬럼 순서와 조회 순서
* 옵티마이저가 알아서 재배열해줘서 꼭 순서 지킬 필요 없음
* 그래도 이왕이면 맞추는게 좋음

## 제네릭
* 객체 타입을 컴파일 시 체크
* 객체의 타입 안정성을 높이고 형변환 번거로움 줄여줌
* 특정한 클래스만 추가되도록 설정 가능
* 런타임 시에는 자신의 타입 정보를 소거함

## 기본 타입과 참조 타입의 차이점
* 기본은 값만 갖고 참조는 신원(주소값)을 가짐
* 참조는 기본 값이 null이다.
* Integer보다 int가 더 효율적이다.
  * == 연산자 시 오류 확률 큼
  * 연산 시 기본 자료형으로 변환되는데 NullPointerException 발생 확률 있음


